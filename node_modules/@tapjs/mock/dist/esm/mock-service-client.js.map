{"version":3,"file":"mock-service-client.js","sourceRoot":"","sources":["../../src/mock-service-client.ts"],"names":[],"mappings":"AAAA,wEAAwE;AACxE,oBAAoB;AACpB,OAAO,EAAE,WAAW,EAAE,MAAM,QAAQ,CAAA;AAEpC,OAAO,EACL,qBAAqB,GAGtB,MAAM,mBAAmB,CAAA;AAE1B,MAAM,KAAK,GAAG,GAAG,EAAE,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAA;AAElD,MAAM,OAAO,iBAAiB;IAC5B,KAAK,CAAa;IAClB,SAAS,GACP,IAAI,GAAG,EAAE,CAAA;IACX,YAAY,IAAiB;QAC3B,IAAI,CAAC,KAAK,GAAG,IAAI,CAAA;QACjB,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,SAAS,EAAE,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAA;QACnD,IAAI,CAAC,KAAK,CAAC,KAAK,EAAE,CAAA;IACpB,CAAC;IACD,QAAQ,CAAC,GAAQ;QACf,IAAI,CAAC,qBAAqB,CAAC,GAAG,CAAC;YAAE,OAAM;QACvC,MAAM,OAAO,GAAG,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,CAAA;QAC1C,aAAa;QACb,qBAAqB;QACrB,IAAI,CAAC,OAAO;YAAE,OAAM;QACpB,oBAAoB;QACpB,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,GAAG,CAAC,EAAE,CAAC,CAAA;QAC7B,IAAI,IAAI,CAAC,SAAS,CAAC,IAAI,KAAK,CAAC,EAAE;YAC7B,IAAI,CAAC,KAAK,CAAC,KAAK,EAAE,CAAA;SACnB;QACD,OAAO,CAAC,GAAG,CAAC,CAAA;IACd,CAAC;IACD,KAAK,CAAC,MAAM,CAAC,GAAuB;QAClC,OAAO,IAAI,OAAO,CAAsB,OAAO,CAAC,EAAE;YAChD,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,EAAE,OAAO,CAAC,CAAA;YACnC,IAAI,CAAC,KAAK,CAAC,GAAG,EAAE,CAAA;YAChB,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,GAAG,CAAC,CAAA;QAC7B,CAAC,CAAC,CAAA;IACJ,CAAC;IACD,KAAK,CAAC,IAAI,CAAC,GAAW;QACpB,MAAM,GAAG,GAAG,MAAM,IAAI,CAAC,MAAM,CAAC;YAC5B,MAAM,EAAE,MAAM;YACd,GAAG;YACH,EAAE,EAAE,KAAK,EAAE;SACZ,CAAC,CAAA;QACF,OAAO,GAAG,CAAC,QAAQ,CAAA;IACrB,CAAC;IACD,KAAK,CAAC,OAAO,CAAC,GAAW,EAAE,SAAkB;QAC3C,OAAO,CACL,SAAS;YACT,CACE,MAAM,IAAI,CAAC,MAAM,CAAC;gBAChB,MAAM,EAAE,SAAS;gBACjB,GAAG;gBACH,SAAS;gBACT,EAAE,EAAE,KAAK,EAAE;aACZ,CAAC,CACH,CAAC,QAAQ,CACX,CAAA;IACH,CAAC;CACF","sourcesContent":["// Created in the loader thread to communicate with the MockService over\n// the message port.\nimport { randomBytes } from 'crypto'\nimport { MessagePort } from 'worker_threads'\nimport {\n  isMockServiceResponse,\n  MockServiceRequest,\n  MockServiceResponse,\n} from './mock-service.js'\n\nconst getId = () => randomBytes(8).toString('hex')\n\nexport class MockServiceClient {\n  #port: MessagePort\n  #requests: Map<string, (res: MockServiceResponse) => void> =\n    new Map()\n  constructor(port: MessagePort) {\n    this.#port = port\n    this.#port.on('message', msg => this.#receive(msg))\n    this.#port.unref()\n  }\n  #receive(msg: any) {\n    if (!isMockServiceResponse(msg)) return\n    const resolve = this.#requests.get(msg.id)\n    // unpossible\n    /* c8 ignore start */\n    if (!resolve) return\n    /* c8 ignore stop */\n    this.#requests.delete(msg.id)\n    if (this.#requests.size === 0) {\n      this.#port.unref()\n    }\n    resolve(msg)\n  }\n  async #fetch(msg: MockServiceRequest) {\n    return new Promise<MockServiceResponse>(resolve => {\n      this.#requests.set(msg.id, resolve)\n      this.#port.ref()\n      this.#port.postMessage(msg)\n    })\n  }\n  async load(url: string) {\n    const res = await this.#fetch({\n      action: 'load',\n      url,\n      id: getId(),\n    })\n    return res.response\n  }\n  async resolve(url: string, parentURL?: string) {\n    return (\n      parentURL &&\n      (\n        await this.#fetch({\n          action: 'resolve',\n          url,\n          parentURL,\n          id: getId(),\n        })\n      ).response\n    )\n  }\n}\n"]}